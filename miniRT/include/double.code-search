# Query: double
# Flags: CaseSensitive RegExp
# ContextLines: 1

34 results - 7 files

include/miniRT.h:
  40  typedef struct s_ambient {
  41:     float ratio;  // ratio of   diffuse light to ambient light
  42      t_color color;

  47      t_vector position;
  48:     float brightness;
  49      t_color color;

  56      t_vector center;
  57:     float diameter;
  58      t_color color;

  62  typedef struct s_intersection {
  63:     float t;
  64      t_color color;

include/render.h:
  12      t_vector orientation;
  13:     float fov;
  14:     float aspect_ratio;
  15:     float viewport_height;
  16:     float viewport_width;
  17      t_vector forward;

include/vector.h:
   9  typedef struct s_vector {
  10:     float x;
  11:     float y;
  12:     float z;
  13  } t_vector;

  15  // Vector operations
  16: t_vector vector_create(float x, float y, float z);
  17  t_vector vector_add(t_vector v1, t_vector v2);
  18  t_vector vector_subtract(t_vector v1, t_vector v2);
  19: float vector_dot_product(t_vector v1, t_vector v2);
  20  t_vector vector_cross_product(t_vector v1, t_vector v2);
  21: float vector_magnitude(t_vector v);
  22  t_vector vector_normalize(t_vector v);
  23: t_vector vector_multiply(t_vector v, float scalar);
  24: float vector_distance(t_vector v1, t_vector v2);
  25  

src/main.c:
  115  t_ray ft_generate_ray(int x, int y, t_scene *scene) {
  116:     float pixel_x = (2.0 * x / WIDTH - 1) * scene->camera.viewport_width / 2;
  117:     float pixel_y = (1 - 2.0 * y / HEIGHT) * scene->camera.viewport_height / 2;
  118      

src/geometry/sphere.c:
   9      t_vector oc = vector_subtract(ray->origin, sphere->center);
  10:     float a = vector_dot_product(ray->direction, ray->direction);
  11:     float b = 2.0 * vector_dot_product(oc, ray->direction);
  12:     float c = vector_dot_product(oc, oc) - (sphere->diameter * sphere->diameter / 4.0);
  13:     float discriminant = b * b - 4 * a * c;
  14  

  17  
  18:     float t = (-b - sqrt(discriminant)) / (2.0 * a);
  19      if (t < 0) {

src/geometry/vector.c:
   7  
   8: t_vector vector_create(float x, float y, float z) {
   9      return (t_vector){x, y, z};

  19  
  20: float vector_dot_product(t_vector v1, t_vector v2) {
  21      return (v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z);

  31  
  32: float vector_magnitude(t_vector v) {
  33      return sqrt(vector_dot_product(v, v));

  36  t_vector vector_normalize(t_vector v) {
  37:     float mag = vector_magnitude(v);
  38      if (mag == 0.0) return v;  // Avoid division by zero

  41  
  42: t_vector vector_multiply(t_vector v, float scalar) {
  43      return vector_create(v.x * scalar, v.y * scalar, v.z * scalar);

  45  
  46: float vector_distance(t_vector v1, t_vector v2) {
  47      return vector_magnitude(vector_subtract(v2, v1));

src/render/camera.c:
  12  
  13:     camera->aspect_ratio = (float)WIDTH / HEIGHT;
  14      camera->viewport_height = 2 * tan((camera->fov * M_PI / 180) / 2);
